// Prototyping extended expression trees for C#.
//
// bartde - October 2015

using System;
using System.Dynamic.Utils;
using System.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using static System.Linq.Expressions.ExpressionStubs;
using LinqError = System.Linq.Expressions.Error;

namespace Microsoft.CSharp.Expressions
{
    /// <summary>
    /// Represents an expression that awaits an asynchronous operation.
    /// </summary>
    public partial class AwaitCSharpExpression : UnaryCSharpExpression
    {
        internal AwaitCSharpExpression(Expression operand, MethodInfo getAwaiterMethod, Type type)
            : base(operand)
        {
            GetAwaiterMethod = getAwaiterMethod;
            Type = type;
        }

        /// <summary>
        /// Returns the node type of this <see cref="CSharpExpression" />. (Inherited from <see cref="CSharpExpression" />.)
        /// </summary>
        /// <returns>The <see cref="CSharpExpressionType"/> that represents this expression.</returns>
        public sealed override CSharpExpressionType CSharpNodeType => CSharpExpressionType.Await;

        /// <summary>
        /// Gets the static type of the expression that this <see cref="Expression" /> represents. (Inherited from <see cref="Expression"/>.)
        /// </summary>
        /// <returns>The <see cref="Type"/> that represents the static type of the expression.</returns>
        public override Type Type { get; }

        /// <summary>
        /// Gets the GetAwaiter method used to await the asynchronous operation.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Awaiter", Justification = "Get a waiter :-)")]
        public MethodInfo GetAwaiterMethod { get; }

        /// <summary>
        /// Dispatches to the specific visit method for this node type.
        /// </summary>
        /// <param name="visitor">The visitor to visit this node with.</param>
        /// <returns>The result of visiting this node.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", Justification = "Following the visitor pattern from System.Linq.Expressions.")]
        protected internal override Expression Accept(CSharpExpressionVisitor visitor)
        {
            return visitor.VisitAwait(this);
        }

        /// <summary>
        /// Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.
        /// </summary>
        /// <param name="operand">The <see cref="UnaryCSharpExpression.Operand" /> property of the result.</param>
        /// <returns>This expression if no children changed, or an expression with the updated children.</returns>
        public AwaitCSharpExpression Update(Expression operand)
        {
            if (operand == Operand)
            {
                return this;
            }

            return Rewrite(operand);
        }

        /// <summary>
        /// Creates a new expression that is like this one, but using the supplied children.
        /// </summary>
        /// <param name="operand">The <see cref="UnaryCSharpExpression.Operand" /> property of the result.</param>
        /// <returns>An expression with the updated children.</returns>
        protected internal virtual AwaitCSharpExpression Rewrite(Expression operand)
        {
            return CSharpExpression.Await(operand, GetAwaiterMethod);
        }

        /// <summary>
        /// Gets a value that indicates whether the expression tree node can be reduced. 
        /// </summary>
        public override bool CanReduce
        {
            get
            {
                // NB: Await nodes can only occur in AsyncLambda expressions and should not get compiled
                //     via the normal expression compiler path of reducing extension nodes. The closest
                //     enclosing AsyncLambda node is responsible for rewriting those.
                //
                // NB: We don't throw from Reduce because it breaks DebugView. By returning false from
                //     this property, we can get the LINQ lambda compiler to bail out upon an attempt to
                //     compile an await expresion without a surrounding async lambda. Unfortunately, it
                //     does so without providing a good error message, which we could only achieve by
                //     throwing from the Reduce method, at the expense of the useful DebugView. Given
                //     that most expressions should be generated by code emitted by the C# compiler, it
                //     seems worth optimizing for the debugging experience.
                return false;
            }
        }

        internal virtual Expression ReduceGetAwaiter()
        {
            Expression getAwaiterCall = GetAwaiterMethod.IsStatic ? Expression.Call(GetAwaiterMethod, Operand) : Expression.Call(Operand, GetAwaiterMethod);
            return getAwaiterCall;
        }

        internal virtual Expression ReduceGetResult(Expression awaiter)
        {
            var getResultMethod = GetGetResult(awaiter.Type);
            var getResultCall = Expression.Call(awaiter, getResultMethod);
            return getResultCall;
        }

        internal virtual Expression ReduceIsCompleted(Expression awaiter)
        {
            return Expression.Property(awaiter, "IsCompleted");
        }

        internal static MethodInfo GetGetResult(Type awaiterType)
        {
            return awaiterType.GetNonGenericMethod("GetResult", BindingFlags.Public | BindingFlags.Instance, Array.Empty<Type>());
        }

        internal static MethodInfo GetGetAwaiter(Type awaiterType)
        {
            return awaiterType.GetNonGenericMethod("GetAwaiter", BindingFlags.Public | BindingFlags.Instance, Array.Empty<Type>());
        }
    }

    partial class CSharpExpression
    {
        /// <summary>
        /// Creates an <see cref="AwaitCSharpExpression"/> that represents awaiting an asynchronous operation.
        /// </summary>
        /// <param name="operand">An <see cref="Expression" /> that specifies the asynchronous operation to await.</param>
        /// <returns>An instance of the <see cref="AwaitCSharpExpression"/>.</returns>
        public static AwaitCSharpExpression Await(Expression operand)
        {
            return Await(operand, null);
        }

        /// <summary>
        /// Creates an <see cref="AwaitCSharpExpression"/> that represents awaiting an asynchronous operation.
        /// </summary>
        /// <param name="operand">An <see cref="Expression" /> that specifies the asynchronous operation to await.</param>
        /// <param name="getAwaiterMethod">The GetAwaiter method used to await the asynchronous operation.</param>
        /// <returns>An instance of the <see cref="AwaitCSharpExpression"/>.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1704:IdentifiersShouldBeSpelledCorrectly", MessageId = "Awaiter", Justification = "Get a waiter :-)")]
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", Justification = "Done by helper method.")]
        public static AwaitCSharpExpression Await(Expression operand, MethodInfo getAwaiterMethod)
        {
            // NB: This is the overload the C# compiler can bind to. Note, however, that a bound await node in Roslyn has
            //     information about IsCompleted and GetResult as well. We can infer the same information at runtime, but
            //     could also add an overload that has all of these.

            ContractUtils.RequiresNotNull(operand, nameof(operand));

            RequiresCanRead(operand, nameof(operand));

            ValidateAwaitPattern(operand.Type, ref getAwaiterMethod, out var resultType);

            return new AwaitCSharpExpression(operand, getAwaiterMethod, resultType);
        }

        private static void ValidateAwaitPattern(Type operandType, ref MethodInfo getAwaiterMethod, out Type resultType)
        {
            if (getAwaiterMethod == null)
            {
                getAwaiterMethod = AwaitCSharpExpression.GetGetAwaiter(operandType);
            }

            ContractUtils.RequiresNotNull(getAwaiterMethod, nameof(getAwaiterMethod));

            ValidateGetAwaiterMethod(operandType, getAwaiterMethod);
            ValidateAwaiterType(getAwaiterMethod.ReturnType, out resultType);
        }

        private static void ValidateGetAwaiterMethod(Type operandType, MethodInfo getAwaiterMethod)
        {
            ValidateMethodInfo(getAwaiterMethod);

            // NB: We don't check whether the name of the method is GetAwaiter, just like we don't check the name of
            //     operator op_* methods in Binary and Unary node factories in LINQ. We could tighten this, but there
            //     is no harm in letting an advanced used specify another method that obeys to the awaiter pattern
            //     other than the predescribed method name. The C# compiler will always specify the MethodInfo in the
            //     emitted factory call.

            var getAwaiterParams = getAwaiterMethod.GetParametersCached();

            if (getAwaiterMethod.IsStatic)
            {
                if (getAwaiterParams.Length != 1)
                {
                    throw Error.GetAwaiterShouldTakeZeroParameters();
                }

                var firstParam = getAwaiterParams[0];
                if (!TypeUtils.AreReferenceAssignable(firstParam.ParameterType, operandType))
                {
                    throw LinqError.ExpressionTypeDoesNotMatchParameter(operandType, firstParam.ParameterType);
                }
            }
            else
            {
                if (getAwaiterParams.Length != 0)
                {
                    throw Error.GetAwaiterShouldTakeZeroParameters();
                }

                if (getAwaiterMethod.IsGenericMethod)
                {
                    throw Error.GetAwaiterShouldNotBeGeneric();
                }
            }

            var returnType = getAwaiterMethod.ReturnType;

            if (returnType == typeof(void) || returnType.IsByRef || returnType.IsPointer)
            {
                throw Error.GetAwaiterShouldReturnAwaiterType();
            }
        }

        private static void ValidateAwaiterType(Type awaiterType, out Type resultType)
        {
            if (!typeof(INotifyCompletion).IsAssignableFrom(awaiterType))
            {
                throw Error.AwaiterTypeShouldImplementINotifyCompletion(awaiterType);
            }

            var isCompleted = awaiterType.GetProperty("IsCompleted", BindingFlags.Public | BindingFlags.Instance);
            if (isCompleted == null || isCompleted.GetMethod == null)
            {
                throw Error.AwaiterTypeShouldHaveIsCompletedProperty(awaiterType);
            }

            if (isCompleted.PropertyType != typeof(bool))
            {
                throw Error.AwaiterIsCompletedShouldReturnBool(awaiterType);
            }

            if (isCompleted.GetIndexParameters().Length != 0)
            {
                throw Error.AwaiterIsCompletedShouldNotBeIndexer(awaiterType);
            }

            var getResult = AwaitCSharpExpression.GetGetResult(awaiterType);
            if (getResult == null || getResult.IsGenericMethodDefinition)
            {
                throw Error.AwaiterTypeShouldHaveGetResultMethod(awaiterType);
            }

            var returnType = getResult.ReturnType;

            if (returnType.IsByRef || returnType.IsPointer)
            {
                throw Error.AwaiterGetResultTypeInvalid(awaiterType);
            }

            resultType = returnType;
        }
    }

    partial class CSharpExpressionVisitor
    {
        /// <summary>
        /// Visits the children of the <see cref="AwaitCSharpExpression" />.
        /// </summary>
        /// <param name="node">The expression to visit.</param>
        /// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1062:Validate arguments of public methods", Justification = "Following the visitor pattern from System.Linq.Expressions.")]
        protected internal virtual Expression VisitAwait(AwaitCSharpExpression node)
        {
            return node.Update(Visit(node.Operand));
        }
    }
}
