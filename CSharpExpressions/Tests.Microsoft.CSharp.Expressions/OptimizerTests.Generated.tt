<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var cases = new Dictionary<string, Dictionary<string, string>>
{
	{
		"Blocks",
		new Dictionary<string, string>
		{
			{
				"Expression.Block(Expression.Empty())",
				"Expression.Empty()"
			},
			{
				"Expression.Block(Expression.Empty(), Expression.Empty())",
				"Expression.Empty()"
			},
			{
				"Expression.Block(CW, Expression.Empty())",
				"CW"
			},
			{
				"Expression.Block(Expression.Empty(), CW)",
				"CW"
			},
			{
				"Expression.Block(Expression.Empty(), CW, Expression.Empty())",
				"CW"
			},
			{
				"Expression.Block(Expression.Empty(), CWI(1), Expression.Empty(), CWI(2), Expression.Empty())",
				"Expression.Block(CWI(1), CWI(2))"
			},
			{
				"Expression.Block(CWI(1), CWI(2))",
				"Expression.Block(CWI(1), CWI(2))"
			},
			{
				"Expression.Block(Expression.Block(CWI(1)), CWI(2))",
				"Expression.Block(CWI(1), CWI(2))"
			},
			{
				"Expression.Block(CWI(1), Expression.Block(CWI(2)))",
				"Expression.Block(CWI(1), CWI(2))"
			},
			{
				"Expression.Block(Expression.Block(CWI(1), CWI(2)))",
				"Expression.Block(CWI(1), CWI(2))"
			},
			{
				"Expression.Block(Expression.Block(CWI(1), Expression.Empty()), Expression.Empty(), Expression.Block(CWI(2), Expression.Empty()))",
				"Expression.Block(CWI(1), CWI(2))"
			},
			{
				"Expression.Block(new[] { P1 }, Expression.Empty())",
				"Expression.Block(new[] { P1 }, Expression.Empty())"
			},
			{
				"Expression.Block(new[] { P1 }, CW)",
				"Expression.Block(new[] { P1 }, CW)"
			},
			{
				"Expression.Block(new[] { P1 }, Expression.Block(CW))",
				"Expression.Block(new[] { P1 }, CW)"
			},
			{
				"Expression.Block(new[] { P1 }, Expression.Block(CW, Expression.Empty()))",
				"Expression.Block(new[] { P1 }, CW)"
			},
			{
				"Expression.Block(new[] { P1 }, Expression.Block(new[] { P2 }, CW))",
				"Expression.Block(new[] { P1 }, Expression.Block(new[] { P2 }, CW))"
			},
			{
				"CSharpExpression.Block(new[] { Expression.Empty() }, RET)",
				"Expression.Empty()"
			},
			{
				"CSharpExpression.Block(new[] { Expression.Block(CW) }, RET)",
				"CW"
			},
			{
				"Expression.Block(CSharpExpression.Block(new[] { CW }, RET))",
				"CW"
			},
			{
				"CSharpExpression.Block(new[] { P1 }, new[] { Expression.Block(CW) }, RET)",
				"CSharpExpression.Block(new[] { P1 }, new[] { CW }, RET)"
			},
			{
				"CSharpExpression.Block(new[] { Expression.Block(new[] { P1 }, CW) }, RET)",
				"Expression.Block(new[] { P1 }, CW)"
			},
			{
				"Expression.Block(new[] { CSharpExpression.Block(new[] { P1 }, new[] { CW }, RET) })",
				"CSharpExpression.Block(new[] { P1 }, new[] { CW }, RET)"
			},
		}
	},
	{
		"Loops",
		new Dictionary<string, string>
		{
			{
				"Expression.Loop(CW)",
				"Expression.Loop(CW)"
			},
			{
				"Expression.Loop(CW, BRK)",
				"Expression.Loop(CW)"
			},
			{
				"Expression.Loop(CW, BRK, CNT)",
				"Expression.Loop(CW)"
			},
			{
				"Expression.Loop(Expression.Block(CW, Expression.Break(BRK)), BRK, CNT)",
				"Expression.Loop(Expression.Block(CW, Expression.Break(BRK)), BRK, null)"
			},
			{
				"Expression.Loop(Expression.Block(CW, Expression.Continue(CNT)), BRK, CNT)",
				"Expression.Loop(Expression.Block(CW, Expression.Continue(CNT)), null, CNT)"
			},
			{
				"Expression.Loop(Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"Expression.Loop(Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.While(B, Expression.Block(CW, Expression.Break(BRK)), BRK, CNT)",
				"CSharpStatement.While(B, Expression.Block(CW, Expression.Break(BRK)), BRK, null)"
			},
			{
				"CSharpStatement.While(B, Expression.Block(CW, Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.While(B, Expression.Block(CW, Expression.Continue(CNT)), null, CNT)"
			},
			{
				"CSharpStatement.While(B, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.While(B, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.Do(Expression.Block(CW, Expression.Break(BRK)), B, BRK, CNT)",
				"CSharpStatement.Do(Expression.Block(CW, Expression.Break(BRK)), B, BRK, null)"
			},
			{
				"CSharpStatement.Do(Expression.Block(CW, Expression.Continue(CNT)), B, BRK, CNT)",
				"CSharpStatement.Do(Expression.Block(CW, Expression.Continue(CNT)), B, null, CNT)"
			},
			{
				"CSharpStatement.Do(Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), B, BRK, CNT)",
				"CSharpStatement.Do(Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), B, BRK, CNT)"
			},
			{
				"CSharpStatement.For(null, B, null, Expression.Block(CW, Expression.Break(BRK)), BRK, CNT)",
				"CSharpStatement.For(null, B, null, Expression.Block(CW, Expression.Break(BRK)), BRK, null)"
			},
			{
				"CSharpStatement.For(null, B, null, Expression.Block(CW, Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(null, B, null, Expression.Block(CW, Expression.Continue(CNT)), null, CNT)"
			},
			{
				"CSharpStatement.For(null, B, null, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(null, B, null, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.ForEach(P1, C, Expression.Block(CW, Expression.Break(BRK)), BRK, CNT)",
				"CSharpStatement.ForEach(P1, C, Expression.Block(CW, Expression.Break(BRK)), BRK, null)"
			},
			{
				"CSharpStatement.ForEach(P1, C, Expression.Block(CW, Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.ForEach(P1, C, Expression.Block(CW, Expression.Continue(CNT)), null, CNT)"
			},
			{
				"CSharpStatement.ForEach(P1, C, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.ForEach(P1, C, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), Expression.PostIncrementAssign(P1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), Expression.PreIncrementAssign(P1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { Expression.PostDecrementAssign(P1), CWI(1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { Expression.PreDecrementAssign(P1), CWI(1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), CSharpExpression.PostIncrementAssign(P1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), CSharpExpression.PreIncrementAssign(P1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), CSharpExpression.PostDecrementAssign(P1), CWI(2) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), CSharpExpression.PreDecrementAssign(P1), CWI(2) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), Expression.PreIncrementAssign(P1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), Expression.PreIncrementAssign(P1) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
			{
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), CSharpExpression.PreDecrementAssign(P1), CWI(2) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)",
				"CSharpStatement.For(new[] { Expression.Assign(P1, Expression.Constant(0)) }, B, new[] { CWI(1), CSharpExpression.PreDecrementAssign(P1), CWI(2) }, Expression.Block(CW, Expression.Break(BRK), Expression.Continue(CNT)), BRK, CNT)"
			},
		}
	},
};
#>
// Prototyping extended expression trees for C#.
//
// bartde - December 2015

using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Linq.Expressions;
using Microsoft.CSharp.Expressions;

namespace Tests
{
    partial class OptimizerTests
    {
<#
foreach (var @case in cases)
{
	var i = 0;
	foreach (var kv in @case.Value)
	{
#>
        [TestMethod]
        public void Optimizer_<#=@case.Key#>_<#=i#>()
        {
            var expression = <#=kv.Key#>;
            var expected = <#=kv.Value#>;
            AssertOptimize(expression, expected);
        }

<#
		i++;
	}
}
#>
    }
}
