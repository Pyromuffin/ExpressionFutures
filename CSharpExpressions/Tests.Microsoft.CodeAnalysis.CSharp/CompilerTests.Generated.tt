// Prototyping extended expression trees for C#.
//
// bartde - November 2015

<#
// NB: When ading a test, it will be *SKIPPED* by default. In order to enable it, review the generated
//     test code and go to the .Verify.cs file to add an entry acknowledging the manual inspection by
//     providing an outcome.

// NB: Editing and saving this file can take a *VERY LONG* time because it invokes the C# compiler at
//     text template processing time. Be patient while Visual Studio appears to hang.
#>
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(SolutionDir)\Tests.Microsoft.CodeAnalysis.CSharp.Helpers\bin\$(Configuration)\Tests.Microsoft.CodeAnalysis.CSharp.Helpers.dll" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Tests.Microsoft.CodeAnalysis.CSharp" #>
<#@ output extension=".cs" #>
<#
var exprs = new[]
{
	// C# 3.0 supported expressions
    "(Expression<Func<int>>)(() => 42)",
    "(Expression<Func<string, int>>)(s => s.Length)",
    
    // Multi-dimensional array initializers
    "(Expression<Func<int[,]>>)(() => new int[1, 1] { { 42 } })",
	"(Expression<Func<int[,]>>)(() => new int[1, 2] { { 42, 43 } })",
	"(Expression<Func<int[,]>>)(() => new int[2, 1] { { 42 }, { 43 } })",
	"(Expression<Func<int[,]>>)(() => new int[2, 2] { { 41, 42 }, { 43, 44 } })",
	 
    // Named parameters for calls
    "(Expression<Func<int>>)(() => Math.Abs(value: 42))",
	"(Expression<Func<string, string>>)(s => s.Substring(startIndex: 42))",
	"(Expression<Func<string, string>>)(s => s.Substring(startIndex: 42, length: 43))",
	"(Expression<Func<string, string>>)(s => s.Substring(length: 43, startIndex: 42))",

	// Named parameters for constructors
    // !!!BUG!!! "(Expression<Func<TimeSpan>>)(() => new TimeSpan(ticks: 42L))",

	// Named parameters for indexers
    "(Expression<Func<List<int>, int>>)(xs => xs[index: 42])",

	// Named parameters for invocations
    "(Expression<Action<Action<int>>>)(a => a(obj: 42))",
	"(Expression<Action<Action<string, int, bool>>>)(a => a(arg2: 42, arg1: \"foo\", arg3: false))",

	// TODO: optional parameters
	 
    // Dynamic unary
	"(Expression<Func<dynamic, dynamic>>)(x => +x)",
    "(Expression<Func<dynamic, dynamic>>)(x => -x)",
	"(Expression<Func<dynamic, dynamic>>)(x => !x)",
	"(Expression<Func<dynamic, dynamic>>)(x => ~x)",
	"(Expression<Func<dynamic, dynamic>>)(x => checked(-x))",

	// Dynamic binary
    "(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a + b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a - b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a * b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a / b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a % b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a & b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a | b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a ^ b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a < b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a <= b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a > b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a >= b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a == b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a != b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a << b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a >> b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a && b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => a || b)",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((a, b) => checked(a + b))",

	// Dynamic convert
    "(Expression<Func<dynamic, int>>)(x => (int)x)",
	"(Expression<Func<dynamic, string>>)(x => (string)x)",
	"(Expression<Func<dynamic, object>>)(x => (object)x)", // NB: gets erased

	// TODO: support for dynamic set member and set index?

	// Dynamic get member
    "(Expression<Func<dynamic, dynamic>>)(x => x.Foo)",

	// Dynamic invoke member
	"(Expression<Func<dynamic, dynamic>>)(x => x.Foo())",
    "(Expression<Func<dynamic, dynamic>>)(x => x.Foo(1, 2))",
	"(Expression<Func<dynamic, dynamic>>)(x => x.Foo(x: 1, y: 2))",
	"(Expression<Func<dynamic, dynamic>>)(x => x.Foo<int>())",
	"(Expression<Func<dynamic, dynamic>>)(x => x.Foo<int, bool>())",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo(y))",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo(y: y))",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo(ref y))",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo(a: ref y))",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo(out y))",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo(a: out y))",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((x, y) => x.Foo(y))",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((x, y) => x.Foo(y: y))",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((x, y) => x.Foo(ref y))",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((x, y) => x.Foo(a: ref y))",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((x, y) => x.Foo(out y))",
	"(Expression<Func<dynamic, dynamic, dynamic>>)((x, y) => x.Foo(a: out y))",
	// !!!BUG!!! "(Expression<Func<string, dynamic, dynamic>>)((s, i) => s.Substring(i))", // REVIEW: Do we have all the info needed about the target which has no CSharpDynamicArgument (compile-time type comes to mind)?
	// !!!BUG!!! "(Expression<Func<dynamic, int>>)(x => int.Parse(x))",

	// Dynamic invoke
	"(Expression<Func<dynamic, dynamic>>)(f => f())",
	"(Expression<Func<dynamic, dynamic>>)(f => f(1, 2))",
	"(Expression<Func<dynamic, dynamic, int, dynamic>>)((f, d, x) => f(d, x))",
	"(Expression<Func<dynamic, dynamic, int, dynamic>>)((f, d, x) => f(a: d, b: x))",
	"(Expression<Func<dynamic, dynamic, int, dynamic>>)((f, d, x) => f(a: ref d, b: out x))",
	"(Expression<Func<Func<int, int, int>, dynamic, int, dynamic>>)((f, d, x) => f(d, x))",

	// Dynamic index
    "(Expression<Func<dynamic, dynamic>>)(x => x.Foo[1])",
	"(Expression<Func<dynamic, dynamic>>)(x => x[1])",
	"(Expression<Func<dynamic, dynamic>>)(x => x.Foo[a: 1])",
	"(Expression<Func<dynamic, dynamic>>)(x => x[a: 1])",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo[y])",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x[y])",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x.Foo[a: y])",
	"(Expression<Func<dynamic, int, dynamic>>)((x, y) => x[a: y])",
	"(Expression<Func<string, dynamic, dynamic>>)((s, i) => s[i])",

	// Dynamic invoke constructor
	"(Expression<Func<dynamic, TimeSpan>>)(x => new TimeSpan(x))",
	 
    // Async/await
    "(Expression<Func<Task<int>, Task<int>>>)(async t => await t)",
    "(Expression<Func<Task<int>, Task<int>>>)(async t => await t.ConfigureAwait(false))",
    "(Expression<Func<dynamic, Task<dynamic>>>)(async d => await d)",
	"(Expression<Func<dynamic, Task<object>>>)(async d => await d)",
	"(Expression<Func<dynamic, Task<int>>>)(async d => await d)",
	 
    // Conditional access
    "(Expression<Func<string, int?>>)(s => s?.Length)",
    "(Expression<Func<string, string>>)(s => s?.ToUpper())",
    // !!!BUG!!! "(Expression<Func<string, char?>>)(s => s?[42])",
    "(Expression<Func<Func<int, int>, int?>>)(f => f?.Invoke(42))",
	 
    // Block
    "(Expression<Action>)(() => { })",
	"(Expression<Action>)(() => { int x; x = 5; })",
	"(Expression<Action>)(() => { int x; x = 5; { int y = x + 1; Console.WriteLine(y); } })",
	 
    // Empty
    "(Expression<Action>)(() => { ; })",
	"(Expression<Action>)(() => { ;; })",
	 
    // Return
    "(Expression<Action>)(() => { return; })",
	"(Expression<Func<int>>)(() => { int x = 42; return x; })",
    "(Expression<Func<int>>)(() => { return 42; })",
	 
    // Label/Goto
    "(Expression<Action>)(() => { goto A; A: Console.Write('A'); })",
    "(Expression<Action>)(() => { A: Console.Write('A'); goto A; })",
	 
    // While
    "(Expression<Action>)(() => { while (true) Console.Write('.'); })",
	 
    // Do
    "(Expression<Action>)(() => { do { Console.Write('.'); } while (true); })",
	 
    // For
    "(Expression<Action>)(() => { for (var i = 0; i < 10; i++) Console.Write(i); })",
    "(Expression<Action>)(() => { for (;;) Console.Write('.'); })",
	 
    // ForEach
    "(Expression<Action<int[]>>)(xs => { foreach (var x in xs) Console.Write(x); })",
    "(Expression<Action<object[]>>)(xs => { foreach (int x in xs) Console.Write(x); })",
	// !!!BUG!!! "(Expression<Action<IEnumerable<int>>>)(xs => { foreach (var x in xs) Console.Write(x); })",
	 
    // Using
    "(Expression<Action<IDisposable>>)(d => { using (d) Console.Write('.'); })",
    "(Expression<Action<IDisposable>>)(d => { using (var e = d) Console.WriteLine(e); })",
	 
    // Lock
    "(Expression<Action<object>>)(o => { lock (o) { Console.Write('.'); } })",
	 
    // Try
    "(Expression<Action>)(() => { try { Console.Write('T'); } finally { Console.Write('F'); } })",
    "(Expression<Action>)(() => { try { Console.Write('T'); } catch { Console.Write('C'); } })",
    "(Expression<Action>)(() => { try { Console.Write('T'); } catch (Exception) { Console.Write('C'); } })",
    "(Expression<Action>)(() => { try { Console.Write('T'); } catch (Exception e) { Console.WriteLine(e); } })",
    // !!!BUG!!! "(Expression<Action>)(() => { try { Console.Write('T'); } catch (Exception e) when (e != null) { Console.WriteLine(e); } })",
    "(Expression<Action>)(() => { try { Console.Write('T'); } catch (InvalidOperationException) { Console.Write('I'); } catch (OverflowException) { Console.Write('O'); } })",
    "(Expression<Action>)(() => { try { Console.Write('T'); } catch (Exception e) { Console.WriteLine(e); } finally { Console.Write('F'); } })",
	 
    // Switch
    "(Expression<Action<int>>)(x => { switch (x) {} })",
    "(Expression<Action<int>>)(x => { switch (x) { case 0: Console.Write('0'); break; } })",
    "(Expression<Action<int>>)(x => { switch (x) { case 0: case 1: Console.Write('A'); break; } })",
    "(Expression<Action<int>>)(x => { switch (x) { case 0: Console.Write('A'); break; default: Console.Write('D'); break; } })",
    "(Expression<Action<int?>>)(x => { switch (x) { case 0: case null: Console.Write('N'); break; } })",
    // !!!BUG!!! "(Expression<Action<int?>>)(x => { switch (x) { case 0: goto case null; case null: Console.Write('N'); break; } })",
    "(Expression<Action<int?>>)(x => { switch (x) { case 0: Console.Write('N'); break; case null: goto case 0; } })",
    "(Expression<Action<int?>>)(x => { switch (x) { case null: goto default; default: Console.Write('N'); break; } })",
};
#>
<#
var sw = Stopwatch.StartNew();
var all = new List<string>();
var toEscapedString = new Func<object, bool, string>((o, multiLine) => "@\"" + (multiLine ? "\r\n" : "") + o.ToString().Replace("\"", "\"\"") + "\"");
var md5 = System.Security.Cryptography.MD5.Create();
var getHash = new Func<string, string>(input =>
{
    var inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
    var hash = md5.ComputeHash(inputBytes);
 
    var sb = new StringBuilder();
    for (var b = hash.Length - 2; b < hash.Length; b++)
    {
        sb.Append(hash[b].ToString("X2"));
    }

    return sb.ToString();
});

TestUtilities.InitializeDomain(this.Host.ResolveAssemblyReference(@"$(SolutionDir)\Tests.Microsoft.CodeAnalysis.CSharp.Helpers\bin\$(Configuration)"));
try
{
#>
// NB: Running these tests can take a *VERY LONG* time because it invokes the C# compiler for every test
//     case in order to obtain an expression tree object. Be patient when running these tests.

// NB: These tests are generated from a list of expressions in the .tt file by invoking the C# compiler at
//     text template processing time by the T4 engine. See TestUtilities for the helper functions that call
//     into the compiler, load the generated assembly, extract the Expression objects through reflection on
//     the generated type, and call DebugView() on those. The resulting DebugView string is emitted in this
//     file as `expected` variables. The original expression is escaped and gets passed ot the GetDebugView
//     helper method to obtain `actual`, which causes the C# compiler to run at test execution time, using
//     the same helper library, thus obtaining the DebugView string again. This serves a number of goals:
//
//       1. At test generation time, a custom Roslyn build can be invoked to test the implicit conversion
//          of a lambda expression to an expression tree, which involves the changes made to support the
//          C# expression library in this solution. Any fatal compiler errors will come out at that time.
//
//       2. Reflection on the properties in the emitted class causes a deferred execution of the factory
//          method calls generated by the Roslyn compiler for the implicit conversion of the lambda to an
//          expression tree. Any exceptions thrown by the factory methods will show up as well during test
//          generation time, allowing issues to be uncovered.
//
//       3. The string literals in the `expected` variables are inspectable by a human to assert that the
//          compiler has indeed generated an expression representation that's homo-iconic to the original
//          expression that was provided in the test.
//
//       4. Any changes to the compiler or the runtime library could cause regressions. Because template
//          processing of the T4 only takes place upon editing the .tt file, the generated test code won't
//          change. As such, any regression can cause test failures which allows to detect any changes to
//          compiler or runtime library behavior.

using Microsoft.VisualStudio.TestTools.UnitTesting;
using static Tests.Microsoft.CodeAnalysis.CSharp.TestUtilities;

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    [TestClass]
    public partial class CompilerTests
    {
<#
var i = 0;
foreach (var expr in exprs)
{
    var before = sw.Elapsed;
#>
        // Elapsed = <#=before#>
<#
    var dbgTest = default(string);
    var ignore = default(string);
    try
    {
        dbgTest = TestUtilities.GetDebugView(expr);
    }
    catch (InvalidProgramException ex)
    {
        dbgTest = "???";
        ignore = ex.Message;
    }

    var cost = sw.Elapsed - before;
    if (ignore != null)
    {
#>
        [Ignore]
<#
        foreach (var line in ignore.Split('\n'))
        {
#>
        // <#=line.TrimEnd('\r')#>
<#
        }
    }

    var exprHash = getHash(expr);
    var dbgTestHash = getHash(dbgTest);

    // NB: Including a hash of the outcome; it anything changes, compilation will fail in Verify.cs,
    //     forcing a human review of all tests again.
    var id = exprHash + "_" + dbgTestHash;
    all.Add(id);
#>
        [TestMethod]
        public void CompilerTest_<#=id#>()
        {
            // <PERF><#=cost.TotalMilliseconds#>ms</PERF>

            // <#=expr#>
            var actual = GetDebugView(<#=toEscapedString(expr, false)#>);
            var expected = <#=toEscapedString(dbgTest, true)#>;
            Assert.AreEqual(expected.TrimStart('\r', '\n'), actual);
            Verify.CompilerTest_<#=id#>();
        }

        partial class Review { /* override in .Verify.cs */ public virtual void CompilerTest_<#=id#>() => INCONCLUSIVE(); }

<#
    i++;
}
#>
        partial class Review
        {
            protected void INCONCLUSIVE() { Assert.Inconclusive(); }
        }

        partial class Reviewed : Review
        {
            private void OK() {}
            private void FAIL(string message = "") { Assert.Fail(message); }
        }

        private Reviewed Verify = new Reviewed();
    }

/*
// NB: The code generated below accepts all tests. *DON'T* just copy/paste this to the .Verify.cs file
//     but review the tests one by one. This output is included in case a minor change is made to debug
//     output produced by DebugView() and all hashes are invalidated. In that case, this output can be
//     copied and pasted into .Verify.cs.

namespace Tests.Microsoft.CodeAnalysis.CSharp
{
    partial class CompilerTests
    {
        partial class Reviewed
        {
<#
foreach (var test in all)
{
#>
            public override void CompilerTest_<#=test#> => OK();
<#
}
#>
        }
    }
}
*/
}
<#
}
finally
{
TestUtilities.UnloadDomain();
}
#>